**线程安全**

Java里进行多线程通讯的主要方式就是共享内存的方式，共享内存的方式主要关注点就两个：可见性和有序性。加上符合操作的原子性，我们可以认为Java线程安全性问题主要关注点就三个：可见性，有序性和原子性。

Java内存模型(JMM)解决了可见性和有序性的问题，而锁解决了原子性的问题。

**锁存在的问题**

Java在1.5版本之前都是靠synchronized关键词来保持同步的，这是通过一致的锁定协议来协调对共享状态的访问，可以保证无论哪个线程访问共享状态的变量，都采用独占的方式访问这些变量。独占锁就是一种悲观锁，所以可以说synchronized是一种悲观锁。

悲观锁机制存在以下问题：

1. 在多线程机制下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。

2. 一个线程持有锁会导致其它所有需要此锁的线程挂起。如果一个优先级高的线程等待一个低优先级的线程释放锁会导致优先级倒置，引起性能问题。

**乐观锁**

​	乐观锁是一种思想，相对悲观锁而言，乐观锁假设一般情况下数据不会造成冲突，所以在数据进行体检更新的时候，才会正式对数据冲突与否进行检测，如果发现冲突了，则返回冲突信息，这让用户决定如何去做。其中实现乐观锁的一种比较典型的就是Compare And Swap(CAS)。

与锁相比，volatile变量是一个更轻量级的同步机制，因为在使用这些变量的时候，不会发生上下文切换和线程调度等操作。但是volatile不能解决原子性问题，因此当一个变量依赖旧值时就不能用volatile变量，最终还要回归到锁机制上来。

**CAS**

CAS是项乐观锁机制，当多个线程尝试使用CAS同时更新一个变量时，只有其中一个线程能更新变量的值，其它线程都失败，失败的线程不会挂起，而是告知在这次竞争中失败，并可再次尝试。

CAS操作包括三个操作数，内存位置(V)，预期原值(A)，和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置的值更新为新值。否则，处理器不做任何操作。

**ABA问题**

线程1从V取出值A，这时线程2从V位置取出A，并将它更新为B，然后线程2又将V位置的数据更新为A。这时候线程1进行CAS操作发现V的值和预期原值匹配，然后更新数据。尽管线程1的CAS操作成功，当并不代表这个过程没有问题。

部分乐观锁的实现是通过版本号的方式来解决ABA问题。乐观锁每次在执行数据更新的操作时，都会带上一个版本号，一旦数据的版本号和操作的版本号一致就进行数据更新操作并对版本号执行＋1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以版本号不会出现ABA问题，因为版本号只会增加不会减少。

**CAS与对象创建**

在JVM创建对象的过程中，对象创建在虚拟机里非常频繁，即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的。可能正在给对象A分配内存空间，指针1还没来得及修改，对象B又同时使用了指针1来分配内存的情况。解决这个问题的方案有两种，其中一个就是CAS配上失败重试的方式保证更新操作的原子性。

