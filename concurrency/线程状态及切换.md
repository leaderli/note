1. **新建(NEW)**: 新创建了一个线程对象。

2. **可运行(RUNNABLE)**:线程对象创建后，由其他线程(比如main线程)调用了start方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权。

3. **运行(RUNNING)**:可运行状态的线程获取了CPU时间片(timeslice)，执行程序代码。

4. **阻塞(BLOCKED)**:阻塞状态是指线程由于某种原因放弃了CPU使用权，也即让出了CPU时间片，暂时停止运行。直到线程再次进入可运行(RUNNABLE)状态，才有机会再次获得CPU时间片转到运行(RUNNING)状态。阻塞的情况分三种：
   1. 等待阻塞:运行(RUNNING)状态的线程执行wait()方法，JVM会把该线程放入等待队列(waitting queue)中，同时释放对象的同步锁。
   2. 同步阻塞:运行(RUNNING)状态的线程在获取对象的同步锁时，若该线程的同步锁被别的线程占用，则JVM会把该线程放入锁池(LOCK POOL)中。
   3. 其他阻塞:运行(RUNNING)状态的线程执行sleep或join方法，JVM会把该线程设置为阻塞(BLOCKED)状态，当sleep超时，join等待线程终止或超时，该线程重新转入可运行(RUNNABLE)状态。

5. **死亡(DEAD)**:线程run方法结束，main方法结束，或者异常原因退出了run方法，则该线程结束生命周期，死亡的线程不可再次复生。
  ![线程的状态图](/Users/li/Documents/note/noteImgPool/线程的状态图.jpg)

**初始状态**

1. 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入初始状态。

**可运行状态**

1. 可运行状态只说你有资格运行，CPU调度程序没有挑选到，永远处于可运行状态。
2. 调用线程的start方法，此线程进入可运行状态。
3. 当前线程的sleep()方法，其他线程join方法结束，此线程进入可运行状态。
4. 锁池的线程获取到对象锁，此线程进入可运行状态。
5. 当前线程时间片用完了，或者调用线程的yield方法，当前线程进入可运行状态。

**运行状态**

 线程调度程序从可运行线程池中挑选一个线程作为作为当前线程所处的状态，这也是线程进入运行状态的唯一方法。

**死亡状态**

1. 当前线程的run方法完成时，或者主线程的main方法完成时，我们就认为它已经死去，也许这个线程对象是活的，当它已经不是一个单独执行的线程。线程一旦死亡，就不会复生。
2. 在一个死去的线程上调用start方法，会抛出java.lang.IllegalThreadStateException异常。

**阻塞状态**

1. 当前线程调用sleep方法，当前线程进入阻塞状态
2. 运行在当前线程里的其它线程t2调用join方法，当前线程进入阻塞状态，直到t2线程结束。
3. 当前线程获取对象锁时，其它线程已持有该对象锁，进入阻塞状态。

**等待队列**

![线程锁竞争过程](/Users/li/Documents/note/noteImgPool/线程锁竞争过程.jpg)

1. 当前线程想调用A的同步方法时，发现对象A被别的线程占有，此时当前线程会进入锁池状态。锁池里面存放的都是想争夺对象A的线程。
2. 当线程1被另外一个线程唤醒时，会进入锁池争夺对象A的锁。
3. 锁池是在同步的环境下才有的概念，一个对象对应一个锁池。

**几个方法的比较**

1. Thread.sleep(long millis),一定是当前线程调用次方法，当前线程进入阻塞状态，但不释放对象锁，millis时间到后，自动进入可运行状态。作用：给其它线程执行机会的最佳方式。
2. Thread.yield(),一定是当前线程调用次方法，当前线程放弃CPU时间片，由运行状态变成可运行状态。yield不会导致阻塞，也无法保证下一次CPU不去挑选该线程执行。
3. t.join(long millis),当前线程==(正在CPU时间片执行的线程==)里调用其它线程的join方法，当前线程进入阻塞状态，但不会释放对象锁，当其它线程执行结束，或millis时间到，当前线程进入可运行状态。
4. obj.wait(),当前线程调用对象的wait方法，当前对象释放对象锁，进入等待队列(阻塞状态)。等待其它线程调用notify或notifyAll，或者wait(long timeout)timeout时间到自动释放唤醒，进入锁池争夺对象锁。
5. obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll会唤醒在此对象监视器上等待的所有线程。

**关于中断**

1. 它不会像stop方法一样中断一个正在运行的线程。线程会不时的监测中断标识，以判断程序是否应该被中断(中断标识值是否为true)。中断只会影响wait sleep join状态的线程，被中断后会抛出java.lang.IllegalThreadStateException异常。
2. synchronized在获取锁的过程中是不能被中断的。
3. 中断是一种状态，interrupt()方法只是讲讲这个状态设置为true，所以说正常执行的代码如果不去检测中断标识，是不会被终止运行的。而wait等阻塞方法，会去检测并抛出异常。如果正常运行的代码添加while(!interrupted()),则同样可以在中断后离开代码体。


