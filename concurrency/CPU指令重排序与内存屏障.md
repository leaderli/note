**指令重排**

现代处理器都会采用指令乱序执行(Out of Order Execution ，简称OOE)的方法，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据的等待，通过乱序执行的技术，处理器可以大大提高执行效率

**AS-IF-SERIAL**

所有的动作(aciton)都可以为了优化而被重新排序，但是必须保证它们重新排序后的执行结果和程序代码本身应有的结果一致。Java编译器，运行时和处理器都会保证单线程运行下的as-if-serial语义。为了保证这一语义，重排序不会发生在有数据依赖的操作中。

```java
int a = 1;
int b = 1;
int c = a + b;
```

将上面的代码编译成java字节码或生成机器指令，可视为以下几步动作(实际可能会忽略或添加某些步骤)

```
对a赋值1
对b赋值1
取a值
取b值
取到的两值相加后赋值给c
```

在上面5个操作，操作1可能和操作2、操作4重排序，操作2可能和操作1、操作3重排序，操作3可能和操作2、操作4重排序，操作4可能和操作1、操作3重排序。但操作1不能和操作3、操作5重排序，操作2不能和操作4、操作5重排序。因为它们存在数据依赖性，一旦重排序， as-if-serial语义无法得到保证。

**内存屏障**

由于现代的处理器系统都是多处理器，而每一个处理器都有自己的缓存，并且这些缓存并不是实时和内存发生信息交换，这样就可能出现一个CPU的缓存数据和另一个CPU缓存数据不一致的问题。而这样在多线程开发中，就有可能造成一些异常问题。

而操作系统底层为了解决这样的问题，提供了一些内存屏障解决这些问题，目前有四种内存屏障

1. LoadLoad内存屏障:对于这样的语句 Load1 LoadLoad Load2 ，在Load2及后续操作要读取的数据被访问前，保证Load1要读取的数据加载完成。
2. StoreStore内存屏障:对于这样的语句 Store1 StoreStore Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
3. LoadStore内存屏障:对于这样的语句 Load1 LoadStore Store2，在Store2及后续写入操作执行前，保证Load1要读取的数据加载完成。
4. StoreLoad内存屏障:对于这样的语句 Store1 StoreLoad Load2，在Load2及后续操作要读取的数据被访问前，保证Store1的写入操作对其它处理器可见。

**使用**

1. 通过synchronized关键词包含的代码区域，当线程进入该区域读取变量信息时，保证读取到的是最新的值。这是因为在同步区内的写入操作，在离开同步区时就将当前线程的数据刷新到内存中，而对数据的读取也不能从缓存中读取，只能从内存中读取，这样就保证了数据读取的有效性，这就插入了StoreStore内存屏障。
2. 使用了volatile关键字修饰的变量，在进行写入操作时，会插入StoreLoad内存屏障。
3. Unsafe.putOrderedObject类似这样的方法,会插入StoreStore内存屏障 
4. Unsafe.putVolatiObject 则是插入了StoreLoad屏障

![volatile重排序规则](/Users/li/Documents/note/noteImgPool/volatile重排序规则.png)

